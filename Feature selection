#ICC
library(irr)
feature1 <- read.csv('data1.csv')
feature2 <- read.csv('data2.csv')
len <- 1220
icc_val<-vector(length=len)
thr <- 0.75
selected <- feature1[feature1$Name %in% feature2$Name,]
for (i in 3:len){
  ratings <- cbind(selected[,i],feature2[,i])
  icc <- icc(ratings, model = "oneway", 
             type = "agreement", 
             unit = "single", r0 = 0, conf.level = 0.95)
  icc_val[i] <- icc$value
}
Index1 <- which(icc_val > thr)
feature3 <- read.csv('data3.csv')
len1 <- 1220
icc_val1<-vector(length=len1)
thr1 <- 0.75
selected1 <- feature2[feature2$Name %in% feature3$Name,]
for (i in 3:len1){
  ratings1 <- cbind(selected1[,i],feature3[,i])
  icc1 <- icc(ratings1, model = "twoway", 
              type = "agreement", 
              unit = "single", r0 = 0, conf.level = 0.95)
  icc_val1[i] <- icc1$value
}
Index2 <- which(icc_val1 > thr1)
Index <- intersect(Index1,Index2)
data <- feature1[,c(1,2,Index)]

#stratified random sampling
library(sampling)
data<-data[order(data$label),]
n <- table(data$label)
nLevel=round(n*0.7)
set.seed(1234)
trainingSamp = strata(data,stratanames="label",size = nLevel,method = "srswor",description = T) 
train_index<-trainingSamp$ID_unit
train <- data[train_index,]
test<-data[-train_index,]

#normalization
means<- sapply(train[,3:1138],mean)
stdev <- sapply(train[,3:1138],sd)
train.scaled <- as.data.frame(scale(train[,3:1138],center=means,scale=stdev)) 
test.scaled <- as.data.frame(scale(test[,3:1138],center=means,scale=stdev))

#redundancy analysis
norm_result <- apply(train.scaled,2,function(x)shapiro.test(x)$p.value)
norm_feature <- train.scaled[which(norm_result >= 0.05)]                    
non_norm_feature <- train.scaled[which(norm_result < 0.05)][-1]
train.scaled <- cbind(norm_feature,non_norm_feature)  
cor_nor <- cor(norm_feature,method='pearson')
cor_all <- cor(train.scaled,method='spearman')
num_nor <- dim(cor_nor)[1]
cor_all[1:num_nor,1:num_nor] <- cor_nor
cor_all[upper.tri(cor_all)] <- 0
diag(cor_all) <- 0
data_reduce = train.scaled[,!apply(cor_all,2,function(x)any(abs(x)>0.9))]

#lasso
set.seed(1)
library(glmnet)
cv_x <- as.matrix(data_reduce)
cv_y <-as.matrix(train$label)
lasso_selection <- cv.glmnet(x=cv_x,y=cv_y,family='binomial',type.measure='deviance',alpha=1,nfolds=10)
par(font.lab=2,mfrow=c(2,1),mar=c(4.5,5,3,2))
plot(x=lasso_selection,las=1,xlab='Log(lambda)')
nocv_lasso <- glmnet(x=cv_x,y=cv_y,family='binomial',alpha=1)
plot(nocv_lasso,xvar='lambda',las=1,lwd=2,xlab='Log(lambda)')
abline(v=log(lasso_selection$lambda.min),lwd=1,lty=3,col='black')
coefPara <- coef(object=lasso_selection,s='lambda.min')
lasso_values <- as.data.frame(which(coefPara!=0,arr.ind=T))
lasso_names <- rownames(lasso_values)[-1] 
lasso_coef <- data.frame(Feature=rownames(lasso_values),Coef=coefPara[which(coefPara!=0,arr.ind=T)])
lasso_coef
lasso_selection$lambda.min
log(lasso_selection$lambda.min)

train.scaled$label <- train$label
train.scaled$Name <- train$Name
test.scaled$label <- test$label
test.scaled$Name <- test$Name
trainm<- train.scaled[,grepl("Name|label|log.sigma.5.0.mm.3D_firstorder_Skewness|wavelet.LLH_glcm_Idmn|wavelet.HLH_glcm_Imc2|log.sigma.2.0.mm.3D_firstorder_Skewness|log.sigma.2.0.mm.3D_glcm_ClusterShade",colnames(train.scaled))]
write.table(trainm,"trainm.csv",row.names=FALSE,col.names=TRUE,sep=",")
testm<- test.scaled[,grepl("Name|label|log.sigma.5.0.mm.3D_firstorder_Skewness|wavelet.LLH_glcm_Idmn|wavelet.HLH_glcm_Imc2|log.sigma.2.0.mm.3D_firstorder_Skewness|log.sigma.2.0.mm.3D_glcm_ClusterShade",colnames(test.scaled))]
write.table(testm,"testm.csv",row.names=FALSE,col.names=TRUE,sep=",")
